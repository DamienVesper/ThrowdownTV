/*! @name videojs-contrib-eme @version 3.7.0 @license Apache-2.0 */
!(function (e, t) { typeof exports === `object` && typeof module !== `undefined` ? t(exports, require(`global/document`), require(`video.js`), require(`global/window`)) : typeof define === `function` && define.amd ? define([`exports`, `global/document`, `video.js`, `global/window`], t) : t(e.videojsContribEme = {}, e.document, e.videojs, e.window); }(this, (e, t, n, r) => { "use strict"; function i () { return (i = Object.assign || function (e) { for (let t = 1; t < arguments.length; t++) { const n = arguments[t]; for (const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]); } return e; }).apply(this, arguments); }t = t && t.hasOwnProperty(`default`) ? t.default : t, n = n && n.hasOwnProperty(`default`) ? n.default : n, r = r && r.hasOwnProperty(`default`) ? r.default : r; const s = function (e, t) { if (e === t) return !0; if (e.byteLength !== t.byteLength) return !1; for (let n = new DataView(e), r = new DataView(t), i = 0; i < n.byteLength; i++) if (n.getUint8(i) !== r.getUint8(i)) return !1; return !0; }; const a = function (e) { return e instanceof Uint8Array || e instanceof Uint16Array ? e.buffer : e; }; const o = function () { const e = n.mergeOptions.apply(n, arguments); return Object.keys(e).forEach((t) => { e[t] === null && delete e[t]; }), e; }; const c = function (e, t, i, s) { const a = (function (e) { const t = (new r.DOMParser()).parseFromString(String.fromCharCode.apply(null, new Uint16Array(e)), `application/xml`); const n = t.getElementsByTagName(`HttpHeaders`)[0]; const i = {}; if (n) for (let s = n.getElementsByTagName(`name`), a = n.getElementsByTagName(`value`), o = 0; o < s.length; o++)i[s[o].childNodes[0].nodeValue] = a[o].childNodes[0].nodeValue; let c; const u = t.getElementsByTagName(`Challenge`)[0]; return u && (c = r.atob(u.childNodes[0].nodeValue)), { headers: i, message: c }; }(t)); const c = a.message; const u = o(a.headers, i.emeHeaders, e.licenseHeaders); n.xhr({ uri: e.url, method: `post`, headers: u, body: c, responseType: `arraybuffer` }, (e, t, n) => { e ? s(e) : t.statusCode >= 400 && t.statusCode <= 599 ? s({}) : s(null, n); }); }; const u = function (e) { let t; return Object.keys(e).forEach((n) => { const s = (function (e) { if (e.supportedConfigurations) return e.supportedConfigurations; const t = {}; const n = e.audioContentType; const r = e.audioRobustness; const s = e.videoContentType; const a = e.videoRobustness; const o = e.persistentState; return (n || r) && (t.audioCapabilities = [i({}, n ? { contentType: n } : {}, r ? { robustness: r } : {})]), (s || a) && (t.videoCapabilities = [i({}, s ? { contentType: s } : {}, a ? { robustness: a } : {})]), o && (t.persistentState = o), [t]; }(e[n])); t = t ? t.catch((e) => { return r.navigator.requestMediaKeySystemAccess(n, s); }) : r.navigator.requestMediaKeySystemAccess(n, s); }), t; }; const y = function (e) { const t = e.mediaKeys; const r = e.initDataType; const i = e.initData; const s = e.options; const a = e.getLicense; const o = e.removeSession; const c = e.eventBus; const u = t.createSession(); return new Promise((e, t) => { u.addEventListener(`message`, (n) => { a(s, n.message).then((t) => { e(u.update(t)); }).catch((e) => { t(e); }); }, !1), u.addEventListener(`keystatuseschange`, (e) => { let t = !1; u.keyStatuses.forEach((r, i) => { switch (c.trigger({ keyId: i, status: r, target: u, type: `keystatuschange` }), r) { case `expired`:t = !0; break; case `internal-error`:n.log.warn(`Key status reported as "internal-error." Leaving the session open since we don't have enough details to know if this error is fatal.`, e); } }), t && u.close().then(() => { o(i); }); }, !1), u.generateRequest(r, i).catch(() => { t(`Unable to create or initialize key session`); }); }); }; const d = function (e, t) { return function (n, r) { return new Promise((i, s) => { e(n, r, (e, n) => { t && t.trigger(`licenserequestattempted`), e ? s(e) : i(n); }); }); }; }; const f = function (e, t) { if (typeof t === `string` && (t = { url: t }), !t.url && !t.getLicense) throw new Error(`Neither URL nor getLicense function provided to get license`); return t.url && !t.getLicense && (t.getLicense = e === `com.microsoft.playready` ? (function (e) { return function (t, n, r) { c(e, n, t, r); }; }(t)) : (function (e) { return function (t, r, i) { const s = o({ "Content-type": `application/octet-stream` }, t.emeHeaders, e.licenseHeaders); n.xhr({ uri: e.url, method: `POST`, responseType: `arraybuffer`, body: r, headers: s }, (e, t, n) => { e ? i(e) : t.statusCode >= 400 && t.statusCode <= 599 ? i({}) : i(null, n); }); }; }(t))), t; }; const m = function (e) { let t; let n; const r = e.video; const i = e.initDataType; const s = e.initData; const a = e.keySystemAccess; const o = e.options; const c = e.removeSession; const u = e.eventBus; let m = Promise.resolve(); void 0 === r.mediaKeysObject && (r.mediaKeysObject = null, r.pendingSessionData = [], m = new Promise((e, i) => { r.keySystem = a.keySystem, (n = f(a.keySystem, o.keySystems[a.keySystem])).getCertificate ? n.getCertificate(o, (n, r) => { n ? i(n) : (t = r, e()); }) : e(a); }).then(() => { return a.createMediaKeys(); }).then((e) => { return (function (e) { const t = e.video; const n = e.certificate; const r = e.createdMediaKeys; t.mediaKeysObject = r; const i = []; n && i.push(r.setServerCertificate(n)); for (let s = 0; s < t.pendingSessionData.length; s++) { const a = t.pendingSessionData[s]; i.push(y({ mediaKeys: t.mediaKeysObject, initDataType: a.initDataType, initData: a.initData, options: a.options, getLicense: a.getLicense, removeSession: a.removeSession, eventBus: a.eventBus })); } return t.pendingSessionData = [], i.push(t.setMediaKeys(r)), Promise.all(i); }({ video: r, certificate: t, createdMediaKeys: e })); }).catch((e) => { return e ? Promise.reject(e) : Promise.reject(`Failed to create and initialize a MediaKeys object`); })); return m.then(() => { return (function (e) { const t = e.video; const n = e.initDataType; const r = e.initData; const i = e.options; const s = e.getLicense; const a = e.removeSession; const o = e.eventBus; return t.mediaKeysObject ? y({ mediaKeys: t.mediaKeysObject, initDataType: n, initData: r, options: i, getLicense: s, removeSession: a, eventBus: o }) : (t.pendingSessionData.push({ initDataType: n, initData: r, options: i, getLicense: s, removeSession: a, eventBus: o }), Promise.resolve()); }({ video: r, initDataType: i, initData: s, options: o, getLicense: r.keySystem ? d(f(r.keySystem, o.keySystems[r.keySystem]).getLicense, u) : null, removeSession: c, eventBus: u })); }); }; const l = function (e) { const t = e.initData; let n = e.id; const r = e.cert; typeof n === `string` && (n = (function (e) { for (var t = new ArrayBuffer(2 * e.length), n = new Uint16Array(t), r = 0; r < e.length; r++)n[r] = e.charCodeAt(r); return n; }(n))); let i = 0; const s = new ArrayBuffer(t.byteLength + 4 + n.byteLength + 4 + r.byteLength); const a = new DataView(s); new Uint8Array(s, i, t.byteLength).set(t), i += t.byteLength, a.setUint32(i, n.byteLength, !0), i += 4; const o = new Uint16Array(s, i, n.length); return o.set(n), i += o.byteLength, a.setUint32(i, r.byteLength, !0), i += 4, new Uint8Array(s, i, r.byteLength).set(r), new Uint8Array(s, 0, s.byteLength); }; const p = function (e, n) { return s = n, r = String.fromCharCode.apply(null, new Uint16Array(s.buffer)), (i = t.createElement(`a`)).href = r, i.hostname; let r, i, s; }; const g = function (e) { const t = e.video; const i = e.initData; const s = e.options; const a = e.eventBus; const c = s.keySystems[`com.apple.fps.1_0`]; const u = c.getCertificate || (function (e) { return function (t, r) { const i = o(t.emeHeaders, e.certificateHeaders); n.xhr({ uri: e.certificateUri, responseType: `arraybuffer`, headers: i }, (e, t, n) => { e ? r(e) : r(null, new Uint8Array(n)); }); }; }(c)); const y = c.getContentId || p; const d = c.getLicense || (function (e) { return function (t, r, i, s) { const a = o({ "Content-type": `application/octet-stream` }, t.emeHeaders, e.licenseHeaders); n.xhr({ uri: e.licenseUri, method: `POST`, responseType: `arraybuffer`, body: i, headers: a }, (e, t, n) => { e ? s(e) : t.statusCode >= 400 && t.statusCode <= 599 ? s({}) : s(null, n); }); }; }(c)); return new Promise((e, t) => { u(s, (n, r) => { n ? t(n) : e(r); }); }).then((e) => { return (function (e) { const t = e.video; const n = e.contentId; const i = e.initData; const s = e.cert; const a = e.options; const o = e.getLicense; const c = e.eventBus; return new Promise((e, u) => { if (!t.webkitKeys) try { t.webkitSetMediaKeys(new r.WebKitMediaKeys(`com.apple.fps.1_0`)); } catch (e) { return void u(`Could not create MediaKeys`); } let y; try { y = t.webkitKeys.createSession(`video/mp4`, l({ id: n, initData: i, cert: s })); } catch (e) { return void u(`Could not create key session`); }y.contentId = n, y.addEventListener(`webkitkeymessage`, (e) => { o(a, n, e.message, (e, t) => { c && c.trigger(`licenserequestattempted`), e ? u(e) : y.update(new Uint8Array(t)); }); }), y.addEventListener(`webkitkeyadded`, () => { e(); }), y.addEventListener(`webkitkeyerror`, () => { const e = y.error; u(`KeySession error: code ${e.code}, systemCode ${e.systemCode}`); }); }); }({ video: t, cert: e, initData: i, getLicense: d, options: s, contentId: y(s, i), eventBus: a })); }); }; const v = function (e, t, n, r) { const i = e.msKeys.createSession(`video/mp4`, t); if (!i) throw new Error(`Could not create key session.`); i.addEventListener(`mskeymessage`, (e) => { !(function (e, t, n, r) { let i = e.keySystems[`com.microsoft.playready`]; if (typeof i.getKey !== `function`) { typeof i === `string` ? i = { url: i } : typeof i === `boolean` && (i = {}), i.url || (i.url = n.destinationURL); const s = function (e, n) { r && r.trigger(`licenserequestattempted`), e ? r.trigger({ message: `Unable to request key from url: ${i.url}`, target: t, type: `mskeyerror` }) : t.update(new Uint8Array(n)); }; i.getLicense ? i.getLicense(e, n.message.buffer, s) : c(i, n.message.buffer, e, s); } else i.getKey(e, n.destinationURL, n.message.buffer, (e, n) => { e ? r.trigger({ message: `Unable to get key: ${e}`, target: t, type: `mskeyerror` }) : t.update(n); }); }(n, i, e, r)); }), i.addEventListener(`mskeyerror`, (e) => { r.trigger({ message: `Unexpected key error from key session with code: ${i.error.code} and systemCode: ${i.error.systemCode}`, target: i, type: `mskeyerror` }); }), i.addEventListener(`mskeyadded`, () => { r.trigger({ target: i, type: `mskeyadded` }); }); }; const h = function (e, t) { for (let n = 0; n < e.length; n++) if (e[n].initData) { const r = a(e[n].initData); const i = a(t); if (s(r, i)) return !0; } return !1; }; const k = function (e, t) { for (let n = 0; n < e.length; n++) if (e[n].initData === t) return void e.splice(n, 1); }; const b = function (e, t, n, r) { if (!t || !t.keySystems) return Promise.resolve(); let i = e.initData; return u(t.keySystems).then((s) => { const a = s.keySystem; return t.keySystems[a] && t.keySystems[a].pssh && (i = t.keySystems[a].pssh), h(n, i) || !i ? Promise.resolve() : (n.push({ initData: i }), m({ video: e.target, initDataType: e.initDataType, initData: i, keySystemAccess: s, options: t, removeSession: k.bind(null, n), eventBus: r })); }); }; const S = function (e, t, n) { return t.keySystems && t.keySystems[`com.apple.fps.1_0`] && e.initData ? g({ video: e.target, initData: e.initData, options: t, eventBus: n }) : Promise.resolve(); }; const w = function (e, t, n, i) { if (t.keySystems && t.keySystems[`com.microsoft.playready`] && !n.reduce((e, t) => { return e || t.playready; }, !1)) { let s = e.initData; t.keySystems[`com.microsoft.playready`] && t.keySystems[`com.microsoft.playready`].pssh && (s = t.keySystems[`com.microsoft.playready`].pssh), s && (n.push({ playready: !0, initData: s }), (function (e) { const t = e.video; const n = e.initData; const i = e.options; const s = e.eventBus; t.msKeys && delete t.msKeys; try { t.msSetMediaKeys(new r.MSMediaKeys(`com.microsoft.playready`)); } catch (e) { throw new Error(`Unable to create media keys for PlayReady key system. Error: ${e.message}`); }v(t, n, i, s); }({ video: e.target, initData: s, options: t, eventBus: i }))); } }; const D = function (e) { return n.mergeOptions(e.currentSource(), e.eme.options); }; const L = function (e) { const t = e.src(); t !== e.eme.activeSrc && (e.eme.activeSrc = t, e.eme.sessions = []); }; const K = function (e) { return function (t) { const n = typeof t === `string` ? t : t && t.message || null; e.error({ code: 5, message: n }); }; }; const C = function (e) { void 0 === e && (e = {}); const t = this; const i = K(t); t.ready(() => { return (function (e, t) { e.$(`.vjs-tech`).tagName.toLowerCase() === `video` && (L(e), r.WebKitMediaKeys ? e.tech_.el_.addEventListener(`webkitneedkey`, (n) => { L(e), S(n, D(e), e.tech_).catch(t); }) : r.MediaKeys ? e.tech_.el_.addEventListener(`encrypted`, (n) => { L(e), b(n, D(e), e.eme.sessions, e.tech_).catch(t); }) : r.MSMediaKeys && (e.tech_.el_.addEventListener(`msneedkey`, (n) => { L(e); try { w(n, D(e), e.eme.sessions, e.tech_); } catch (e) { t(e); } }), e.tech_.on(`mskeyerror`, t), e.on(`dispose`, () => { e.tech_.off(`mskeyerror`, t); }))); }(t, i)); }), t.eme = { initializeMediaKeys: function (r, s, a) { void 0 === r && (r = {}), void 0 === s && (s = function () {}), void 0 === a && (a = !1); const o = n.mergeOptions(t.currentSource(), e, r); const c = { initDataType: `cenc`, initData: null, target: t.tech_.el_ }; if (L(t), t.tech_.el_.setMediaKeys)b(c, o, t.eme.sessions, t.tech_).then(() => { return s(); }).catch((e) => { s(e), a || i(e); }); else if (t.tech_.el_.msSetMediaKeys) { const u = function e (n) { t.tech_.off(`mskeyadded`, e), t.tech_.off(`mskeyerror`, e), n.type === `mskeyerror` ? (s(n.target.error), a || i(n.message)) : s(); }; t.tech_.one(`mskeyadded`, u), t.tech_.one(`mskeyerror`, u); try { w(c, o, t.eme.sessions, t.tech_); } catch (e) { t.tech_.off(`mskeyadded`, u), t.tech_.off(`mskeyerror`, u), s(e), a || i(e); } } }, options: e }; }; (n.registerPlugin || n.plugin)(`eme`, C), e.hasSession = h, e.removeSession = k, e.handleEncryptedEvent = b, e.handleWebKitNeedKeyEvent = S, e.handleMsNeedKeyEvent = w, e.getOptions = D, e.setupSessions = L, e.emeErrorHandler = K, e.default = C, Object.defineProperty(e, `__esModule`, { value: !0 }); }));
