/*! @name videojs-contrib-dash @version 2.11.0 @license Apache-2.0 */
!(function (e, a) { typeof exports === `object` && typeof module !== `undefined` ? module.exports = a(require(`dashjs`), require(`video.js`), require(`global/window`), require(`global/document`)) : typeof define === `function` && define.amd ? define([`dashjs`, `video.js`, `global/window`, `global/document`], a) : e.videojsDash = a(e.dashjs, e.videojs, e.window, e.document); }(this, (e, a, r, t) => { "use strict"; function i (r, t) { r.dash.mediaPlayer.on(e.MediaPlayer.events.PLAYBACK_METADATA_LOADED, ((r, t) => { const i = r.dash.mediaPlayer; const n = i.getTracksFor(`audio`); const o = r.audioTracks(); function s (e) { return `dash-audio-${e}`; } function l (e, a) { return e.find((e) => { return s(e.index) === a.id; }); }o.length && t.clearTracks([`audio`]); const d = i.getCurrentTrackFor(`audio`); n.forEach((e) => { let t, i; if (Array.isArray(e.labels)) for (let n = 0; n < e.labels.length; n++) if (e.labels[n].lang && r.language().indexOf(e.labels[n].lang.toLowerCase()) !== -1) { t = e.labels[n]; break; }t ? i = t.text : Array.isArray(e.labels) && e.labels.length === 1 ? i = e.labels[0].text : (i = e.lang, e.roles && e.roles.length && (i += ` (${e.roles.join(`, `)})`)), o.addTrack(new a.AudioTrack({ enabled: e === d, id: s(e.index), kind: e.kind || `main`, label: i, language: e.lang })); }); const c = function () { for (let e = 0; e < o.length; e++) { const a = o[e]; if (a.enabled) { const r = l(n, a); i.setCurrentTrack(r); } } }; o.addEventListener(`change`, c), r.dash.mediaPlayer.on(e.MediaPlayer.events.STREAM_TEARDOWN_COMPLETE, () => { o.removeEventListener(`change`, c); }); }).bind(null, r, t)); } function n (t, i, n) { r.VTTCue && !/\[native code\]/.test(r.VTTCue.toString()) && (r.VTTCue = !1); let o = []; if (i.featuresNativeTextTracks)a.log.error(`You must pass {html: {nativeCaptions: false}} in the videojs constructor to use text tracks in videojs-contrib-dash`); else { var s = t.dash.mediaPlayer; s.on(e.MediaPlayer.events.TEXT_TRACKS_ADDED, l), s.on(e.MediaPlayer.events.CAN_PLAY, () => { s.off(e.MediaPlayer.events.TEXT_TRACKS_ADDED, l); }); } function l (a) { a.index; const r = a.tracks; s.off(e.MediaPlayer.events.TEXT_TRACKS_ADDED, l), o.forEach(t.removeRemoteTextTrack.bind(t)), o = [], r.length && (o = (function (a, r, t) { const i = []; const n = t.map((e) => { let r; if (Array.isArray(e.labels)) for (let t = 0; t < e.labels.length; t++) if (e.labels[t].lang && a.language().indexOf(e.labels[t].lang.toLowerCase()) !== -1) { r = e.labels[t]; break; } return { dashTrack: e, trackConfig: { label: r ? r.text : Array.isArray(e.labels) && e.labels.length === 1 ? e.labels[0].text : e.lang || e.label, language: e.lang, srclang: e.lang, kind: e.kind } }; }).map((e) => { const r = e.trackConfig; const t = e.dashTrack; const n = a.addRemoteTextTrack(r, !1); return i.push({ textTrack: n.track, dashTrack: t }), n; }); function o () { for (var e = a.dash.mediaPlayer, r = a.textTracks(), n = -1, o = function (e) { const a = r[e]; if (a.mode === `showing`) { const o = (function (e, a) { for (let r = 0; r < e.length; r++) if (a(e[r])) return e[r]; }(i, (e) => { return e.textTrack === a; })); const s = o ? o.dashTrack : null; s && (n = t.indexOf(s)); } }, s = 0; s < r.length; s += 1)o(s); n !== e.getCurrentTextTrackIndex() && e.setTextTrack(n); } return a.textTracks().on(`change`, o), a.dash.mediaPlayer.on(e.MediaPlayer.events.STREAM_TEARDOWN_COMPLETE, () => { a.textTracks().off(`change`, o); }), o(), n; }(t, 0, r))); } }e = e && e.hasOwnProperty(`default`) ? e.default : e, a = a && a.hasOwnProperty(`default`) ? a.default : a, r = r && r.hasOwnProperty(`default`) ? r.default : r, t = t && t.hasOwnProperty(`default`) ? t.default : t; const o = (function () { function r (t, o, s) { const l = this; if (s = s || o.options_, this.player = a(s.playerId), this.player.dash = this.player.dash || {}, this.tech_ = o, this.el_ = o.el(), this.elParent_ = this.el_.parentNode, this.hasFiniteDuration_ = !1, t.src) { o.isReady_ = !1, r.updateSourceData && (a.log.warn(`updateSourceData has been deprecated. Please switch to using hook("updatesource", callback).`), t = r.updateSourceData(t)), r.hooks(`updatesource`).forEach((e) => { t = e(t); }); const d = t.src; this.keySystemOptions_ = r.buildDashJSProtData(t.keySystemOptions), this.player.dash.mediaPlayer = e.MediaPlayer().create(), this.mediaPlayer_ = this.player.dash.mediaPlayer, this.mediaPlayer_.setTextDefaultEnabled(!1), r.useVideoJSDebug && (a.log.warn(`useVideoJSDebug has been deprecated. Please switch to using hook("beforeinitialize", callback).`), r.useVideoJSDebug(this.mediaPlayer_)), r.beforeInitialize && (a.log.warn(`beforeInitialize has been deprecated. Please switch to using hook("beforeinitialize", callback).`), r.beforeInitialize(this.player, this.mediaPlayer_)), r.hooks(`beforeinitialize`).forEach((e) => { e(l.player, l.mediaPlayer_); }), this.mediaPlayer_.initialize(), this.retriggerError_ = function (e) { if (e.error === `capability` && e.event === `mediasource`)l.player.error({ code: 4, message: `The media cannot be played because it requires a feature that your browser does not support.` }); else if (e.error !== `manifestError` || e.event.id !== `createParser` && e.event.id !== `codec` && e.event.id !== `nostreams` && e.event.id !== `nostreamscomposed` && e.event.id !== `parse` && e.event.id !== `multiplexedrep`) if (e.error === `mediasource`)e.event.match(`MEDIA_ERR_ABORTED`) ? l.player.error({ code: 1, message: e.event }) : e.event.match(`MEDIA_ERR_NETWORK`) ? l.player.error({ code: 2, message: e.event }) : e.event.match(`MEDIA_ERR_DECODE`) ? l.player.error({ code: 3, message: e.event }) : e.event.match(`MEDIA_ERR_SRC_NOT_SUPPORTED`) ? l.player.error({ code: 4, message: e.event }) : e.event.match(`MEDIA_ERR_ENCRYPTED`) ? l.player.error({ code: 5, message: e.event }) : (e.event.match(`UNKNOWN`), l.player.error({ code: 4, message: e.event })); else if (e.error === `capability` && e.event === `encryptedmedia`)l.player.error({ code: 5, message: `The media cannot be played because it requires encryption features that your browser does not support.` }); else if (e.error === `key_session`)l.player.error({ code: 5, message: e.event }); else if (e.error === `download`)l.player.error({ code: 2, message: `The media playback was aborted because too many consecutive download errors occurred.` }); else { if (e.error !== `mssError`) return; l.player.error({ code: 3, message: e.event }); } else l.player.error({ code: 4, message: e.event.message }); setTimeout(() => { l.mediaPlayer_.reset(); }, 10); }, this.mediaPlayer_.on(e.MediaPlayer.events.ERROR, this.retriggerError_), this.getDuration_ = function (e) { const a = e.data.Period_asArray; const r = l.hasFiniteDuration_; e.data.mediaPresentationDuration || a[a.length - 1].duration ? l.hasFiniteDuration_ = !0 : l.hasFiniteDuration_ = !1, l.hasFiniteDuration_ !== r && l.player.trigger(`durationchange`); }, this.mediaPlayer_.on(e.MediaPlayer.events.MANIFEST_LOADED, this.getDuration_), s.dash && Object.keys(s.dash).forEach((e) => { let r; const t = `set${e.charAt(0).toUpperCase()}${e.slice(1)}`; let i = s.dash[e]; l.mediaPlayer_.hasOwnProperty(t) && (a.log.warn(`Using dash options in videojs-contrib-dash without the set prefix has been deprecated. Change '${e}' to '${t}'`), e = t), l.mediaPlayer_.hasOwnProperty(e) ? (Array.isArray(i) || (i = [i]), (r = l.mediaPlayer_)[e].apply(r, i)) : a.log.warn(`Warning: dash configuration option unrecognized: ${e}`); }), this.mediaPlayer_.attachView(this.el_), this.mediaPlayer_.setAutoPlay(!1), i.call(null, this.player, o), n.call(null, this.player, o, s), this.mediaPlayer_.setProtectionData(this.keySystemOptions_), this.mediaPlayer_.attachSource(d), this.tech_.triggerReady(); } }r.buildDashJSProtData = function (e) { const r = {}; if (!e || !Array.isArray(e)) return null; for (let t = 0; t < e.length; t++) { const i = e[t]; const n = a.mergeOptions({}, i.options); n.licenseUrl && (n.serverURL = n.licenseUrl, delete n.licenseUrl), r[i.name] = n; } return r; }; const t = r.prototype; return t.dispose = function () { this.mediaPlayer_ && (this.mediaPlayer_.off(e.MediaPlayer.events.ERROR, this.retriggerError_), this.mediaPlayer_.off(e.MediaPlayer.events.MANIFEST_LOADED, this.getDuration_), this.mediaPlayer_.reset()), this.player.dash && delete this.player.dash; }, t.duration = function () { return this.mediaPlayer_.isDynamic() && !this.hasFiniteDuration_ ? 1 / 0 : this.mediaPlayer_.duration(); }, r.hooks = function (e, a) { return r.hooks_[e] = r.hooks_[e] || [], a && (r.hooks_[e] = r.hooks_[e].concat(a)), r.hooks_[e]; }, r.hook = function (e, a) { r.hooks(e, a); }, r.removeHook = function (e, a) { const t = r.hooks(e).indexOf(a); return t !== -1 && (r.hooks_[e] = r.hooks_[e].slice(), r.hooks_[e].splice(t, 1), !0); }, r; }()); o.hooks_ = {}; return a.DashSourceHandler = function () { return { canHandleSource: function (e) { return (function (e) { e = JSON.parse(JSON.stringify(e)), o.updateSourceData && (a.log.warn(`updateSourceData has been deprecated. Please switch to using hook("updatesource", callback).`), e = o.updateSourceData(e)), o.hooks(`updatesource`).forEach((a) => { e = a(e); }); const i = t.createElement(`video`); return !(e.keySystemOptions && !r.navigator.requestMediaKeySystemAccess && !i.msSetMediaKeys); }(e)) ? a.DashSourceHandler.canPlayType(e.type) ? `probably` : /\.mpd/i.test(e.src) ? `maybe` : `` : ``; }, handleSource: function (e, a, r) { return new o(e, a, r); }, canPlayType: function (e) { return a.DashSourceHandler.canPlayType(e); } }; }, a.DashSourceHandler.canPlayType = function (e) { return /^application\/dash\+xml/i.test(e) ? `probably` : ``; }, r.MediaSource && a.getTech(`Html5`).registerSourceHandler(a.DashSourceHandler(), 0), a.Html5DashJS = o, o; }));
